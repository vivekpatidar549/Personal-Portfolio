{"version":3,"file":"static/js/2847.aa06f053.chunk.js","mappings":"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","sources":["../node_modules/@tsparticles/shape-image/browser/GifUtils/Constants.js","../node_modules/@tsparticles/shape-image/browser/GifUtils/ByteStream.js","../node_modules/@tsparticles/shape-image/browser/GifUtils/Utils.js","../node_modules/@tsparticles/shape-image/browser/ImageDrawer.js"],"sourcesContent":["export const InterlaceOffsets = [0, 4, 2, 1];\nexport const InterlaceSteps = [8, 8, 4, 2];\n","export class ByteStream {\n    constructor(bytes) {\n        this.pos = 0;\n        this.data = new Uint8ClampedArray(bytes);\n    }\n    getString(count) {\n        const slice = this.data.slice(this.pos, this.pos + count);\n        this.pos += slice.length;\n        return slice.reduce((acc, curr) => acc + String.fromCharCode(curr), \"\");\n    }\n    nextByte() {\n        return this.data[this.pos++];\n    }\n    nextTwoBytes() {\n        const increment = 2, previous = 1, shift = 8;\n        this.pos += increment;\n        return this.data[this.pos - increment] + (this.data[this.pos - previous] << shift);\n    }\n    readSubBlocks() {\n        let blockString = \"\", size = 0;\n        const minCount = 0, emptySize = 0;\n        do {\n            size = this.data[this.pos++];\n            for (let count = size; --count >= minCount; blockString += String.fromCharCode(this.data[this.pos++])) {\n            }\n        } while (size !== emptySize);\n        return blockString;\n    }\n    readSubBlocksBin() {\n        let size = this.data[this.pos], len = 0;\n        const emptySize = 0, increment = 1;\n        for (let offset = 0; size !== emptySize; offset += size + increment, size = this.data[this.pos + offset]) {\n            len += size;\n        }\n        const blockData = new Uint8Array(len);\n        size = this.data[this.pos++];\n        for (let i = 0; size !== emptySize; size = this.data[this.pos++]) {\n            for (let count = size; --count >= emptySize; blockData[i++] = this.data[this.pos++]) {\n            }\n        }\n        return blockData;\n    }\n    skipSubBlocks() {\n        for (const increment = 1, noData = 0; this.data[this.pos] !== noData; this.pos += this.data[this.pos] + increment) {\n        }\n        this.pos++;\n    }\n}\n","import { InterlaceOffsets, InterlaceSteps } from \"./Constants.js\";\nimport { ByteStream } from \"./ByteStream.js\";\nconst origin = {\n    x: 0,\n    y: 0,\n}, defaultFrame = 0, half = 0.5, initialTime = 0, firstIndex = 0, defaultLoopCount = 0;\nfunction parseColorTable(byteStream, count) {\n    const colors = [];\n    for (let i = 0; i < count; i++) {\n        colors.push({\n            r: byteStream.data[byteStream.pos],\n            g: byteStream.data[byteStream.pos + 1],\n            b: byteStream.data[byteStream.pos + 2],\n        });\n        byteStream.pos += 3;\n    }\n    return colors;\n}\nfunction parseExtensionBlock(byteStream, gif, getFrameIndex, getTransparencyIndex) {\n    switch (byteStream.nextByte()) {\n        case 249: {\n            const frame = gif.frames[getFrameIndex(false)];\n            byteStream.pos++;\n            const packedByte = byteStream.nextByte();\n            frame.GCreserved = (packedByte & 0xe0) >>> 5;\n            frame.disposalMethod = (packedByte & 0x1c) >>> 2;\n            frame.userInputDelayFlag = (packedByte & 2) === 2;\n            const transparencyFlag = (packedByte & 1) === 1;\n            frame.delayTime = byteStream.nextTwoBytes() * 0xa;\n            const transparencyIndex = byteStream.nextByte();\n            if (transparencyFlag) {\n                getTransparencyIndex(transparencyIndex);\n            }\n            byteStream.pos++;\n            break;\n        }\n        case 255: {\n            byteStream.pos++;\n            const applicationExtension = {\n                identifier: byteStream.getString(8),\n                authenticationCode: byteStream.getString(3),\n                data: byteStream.readSubBlocksBin(),\n            };\n            gif.applicationExtensions.push(applicationExtension);\n            break;\n        }\n        case 254: {\n            gif.comments.push([getFrameIndex(false), byteStream.readSubBlocks()]);\n            break;\n        }\n        case 1: {\n            if (gif.globalColorTable.length === 0) {\n                throw new EvalError(\"plain text extension without global color table\");\n            }\n            byteStream.pos++;\n            gif.frames[getFrameIndex(false)].plainTextData = {\n                left: byteStream.nextTwoBytes(),\n                top: byteStream.nextTwoBytes(),\n                width: byteStream.nextTwoBytes(),\n                height: byteStream.nextTwoBytes(),\n                charSize: {\n                    width: byteStream.nextTwoBytes(),\n                    height: byteStream.nextTwoBytes(),\n                },\n                foregroundColor: byteStream.nextByte(),\n                backgroundColor: byteStream.nextByte(),\n                text: byteStream.readSubBlocks(),\n            };\n            break;\n        }\n        default:\n            byteStream.skipSubBlocks();\n            break;\n    }\n}\nasync function parseImageBlock(byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback) {\n    const frame = gif.frames[getFrameIndex(true)];\n    frame.left = byteStream.nextTwoBytes();\n    frame.top = byteStream.nextTwoBytes();\n    frame.width = byteStream.nextTwoBytes();\n    frame.height = byteStream.nextTwoBytes();\n    const packedByte = byteStream.nextByte(), localColorTableFlag = (packedByte & 0x80) === 0x80, interlacedFlag = (packedByte & 0x40) === 0x40;\n    frame.sortFlag = (packedByte & 0x20) === 0x20;\n    frame.reserved = (packedByte & 0x18) >>> 3;\n    const localColorCount = 1 << ((packedByte & 7) + 1);\n    if (localColorTableFlag) {\n        frame.localColorTable = parseColorTable(byteStream, localColorCount);\n    }\n    const getColor = (index) => {\n        const { r, g, b } = (localColorTableFlag ? frame.localColorTable : gif.globalColorTable)[index];\n        if (index !== getTransparencyIndex(null)) {\n            return { r, g, b, a: 255 };\n        }\n        return { r, g, b, a: avgAlpha ? ~~((r + g + b) / 3) : 0 };\n    };\n    const image = (() => {\n        try {\n            return new ImageData(frame.width, frame.height, { colorSpace: \"srgb\" });\n        }\n        catch (error) {\n            if (error instanceof DOMException && error.name === \"IndexSizeError\") {\n                return null;\n            }\n            throw error;\n        }\n    })();\n    if (image == null) {\n        throw new EvalError(\"GIF frame size is to large\");\n    }\n    const minCodeSize = byteStream.nextByte(), imageData = byteStream.readSubBlocksBin(), clearCode = 1 << minCodeSize;\n    const readBits = (pos, len) => {\n        const bytePos = pos >>> 3, bitPos = pos & 7;\n        return (((imageData[bytePos] + (imageData[bytePos + 1] << 8) + (imageData[bytePos + 2] << 16)) &\n            (((1 << len) - 1) << bitPos)) >>>\n            bitPos);\n    };\n    if (interlacedFlag) {\n        for (let code = 0, size = minCodeSize + 1, pos = 0, dic = [[0]], pass = 0; pass < 4; pass++) {\n            if (InterlaceOffsets[pass] < frame.height) {\n                let pixelPos = 0, lineIndex = 0, exit = false;\n                while (!exit) {\n                    const last = code;\n                    code = readBits(pos, size);\n                    pos += size + 1;\n                    if (code === clearCode) {\n                        size = minCodeSize + 1;\n                        dic.length = clearCode + 2;\n                        for (let i = 0; i < dic.length; i++) {\n                            dic[i] = i < clearCode ? [i] : [];\n                        }\n                    }\n                    else {\n                        if (code >= dic.length) {\n                            dic.push(dic[last].concat(dic[last][0]));\n                        }\n                        else if (last !== clearCode) {\n                            dic.push(dic[last].concat(dic[code][0]));\n                        }\n                        for (const item of dic[code]) {\n                            const { r, g, b, a } = getColor(item);\n                            image.data.set([r, g, b, a], InterlaceOffsets[pass] * frame.width +\n                                InterlaceSteps[pass] * lineIndex +\n                                (pixelPos % (frame.width * 4)));\n                            pixelPos += 4;\n                        }\n                        if (dic.length === 1 << size && size < 0xc) {\n                            size++;\n                        }\n                    }\n                    if (pixelPos === frame.width * 4 * (lineIndex + 1)) {\n                        lineIndex++;\n                        if (InterlaceOffsets[pass] + InterlaceSteps[pass] * lineIndex >= frame.height) {\n                            exit = true;\n                        }\n                    }\n                }\n            }\n            progressCallback?.(byteStream.pos / (byteStream.data.length - 1), getFrameIndex(false) + 1, image, { x: frame.left, y: frame.top }, { width: gif.width, height: gif.height });\n        }\n        frame.image = image;\n        frame.bitmap = await createImageBitmap(image);\n    }\n    else {\n        let code = 0, size = minCodeSize + 1, pos = 0, pixelPos = -4, exit = false;\n        const dic = [[0]];\n        while (!exit) {\n            const last = code;\n            code = readBits(pos, size);\n            pos += size;\n            if (code === clearCode) {\n                size = minCodeSize + 1;\n                dic.length = clearCode + 2;\n                for (let i = 0; i < dic.length; i++) {\n                    dic[i] = i < clearCode ? [i] : [];\n                }\n            }\n            else {\n                if (code === clearCode + 1) {\n                    exit = true;\n                    break;\n                }\n                if (code >= dic.length) {\n                    dic.push(dic[last].concat(dic[last][0]));\n                }\n                else if (last !== clearCode) {\n                    dic.push(dic[last].concat(dic[code][0]));\n                }\n                for (const item of dic[code]) {\n                    const { r, g, b, a } = getColor(item);\n                    image.data.set([r, g, b, a], (pixelPos += 4));\n                }\n                if (dic.length >= 1 << size && size < 0xc) {\n                    size++;\n                }\n            }\n        }\n        frame.image = image;\n        frame.bitmap = await createImageBitmap(image);\n        progressCallback?.((byteStream.pos + 1) / byteStream.data.length, getFrameIndex(false) + 1, frame.image, { x: frame.left, y: frame.top }, { width: gif.width, height: gif.height });\n    }\n}\nasync function parseBlock(byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback) {\n    switch (byteStream.nextByte()) {\n        case 59:\n            return true;\n        case 44:\n            await parseImageBlock(byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback);\n            break;\n        case 33:\n            parseExtensionBlock(byteStream, gif, getFrameIndex, getTransparencyIndex);\n            break;\n        default:\n            throw new EvalError(\"undefined block found\");\n    }\n    return false;\n}\nexport function getGIFLoopAmount(gif) {\n    for (const extension of gif.applicationExtensions) {\n        if (extension.identifier + extension.authenticationCode !== \"NETSCAPE2.0\") {\n            continue;\n        }\n        return extension.data[1] + (extension.data[2] << 8);\n    }\n    return NaN;\n}\nexport async function decodeGIF(gifURL, progressCallback, avgAlpha) {\n    if (!avgAlpha)\n        avgAlpha = false;\n    const res = await fetch(gifURL);\n    if (!res.ok && res.status === 404) {\n        throw new EvalError(\"file not found\");\n    }\n    const buffer = await res.arrayBuffer();\n    const gif = {\n        width: 0,\n        height: 0,\n        totalTime: 0,\n        colorRes: 0,\n        pixelAspectRatio: 0,\n        frames: [],\n        sortFlag: false,\n        globalColorTable: [],\n        backgroundImage: new ImageData(1, 1, { colorSpace: \"srgb\" }),\n        comments: [],\n        applicationExtensions: [],\n    }, byteStream = new ByteStream(new Uint8ClampedArray(buffer));\n    if (byteStream.getString(6) !== \"GIF89a\") {\n        throw new Error(\"not a supported GIF file\");\n    }\n    gif.width = byteStream.nextTwoBytes();\n    gif.height = byteStream.nextTwoBytes();\n    const packedByte = byteStream.nextByte(), globalColorTableFlag = (packedByte & 0x80) === 0x80;\n    gif.colorRes = (packedByte & 0x70) >>> 4;\n    gif.sortFlag = (packedByte & 8) === 8;\n    const globalColorCount = 1 << ((packedByte & 7) + 1), backgroundColorIndex = byteStream.nextByte();\n    gif.pixelAspectRatio = byteStream.nextByte();\n    if (gif.pixelAspectRatio !== 0) {\n        gif.pixelAspectRatio = (gif.pixelAspectRatio + 0xf) / 0x40;\n    }\n    if (globalColorTableFlag) {\n        gif.globalColorTable = parseColorTable(byteStream, globalColorCount);\n    }\n    const backgroundImage = (() => {\n        try {\n            return new ImageData(gif.width, gif.height, { colorSpace: \"srgb\" });\n        }\n        catch (error) {\n            if (error instanceof DOMException && error.name === \"IndexSizeError\") {\n                return null;\n            }\n            throw error;\n        }\n    })();\n    if (backgroundImage == null) {\n        throw new Error(\"GIF frame size is to large\");\n    }\n    const { r, g, b } = gif.globalColorTable[backgroundColorIndex];\n    backgroundImage.data.set(globalColorTableFlag ? [r, g, b, 255] : [0, 0, 0, 0]);\n    for (let i = 4; i < backgroundImage.data.length; i *= 2) {\n        backgroundImage.data.copyWithin(i, 0, i);\n    }\n    gif.backgroundImage = backgroundImage;\n    let frameIndex = -1, incrementFrameIndex = true, transparencyIndex = -1;\n    const getframeIndex = (increment) => {\n        if (increment) {\n            incrementFrameIndex = true;\n        }\n        return frameIndex;\n    };\n    const getTransparencyIndex = (newValue) => {\n        if (newValue != null) {\n            transparencyIndex = newValue;\n        }\n        return transparencyIndex;\n    };\n    try {\n        do {\n            if (incrementFrameIndex) {\n                gif.frames.push({\n                    left: 0,\n                    top: 0,\n                    width: 0,\n                    height: 0,\n                    disposalMethod: 0,\n                    image: new ImageData(1, 1, { colorSpace: \"srgb\" }),\n                    plainTextData: null,\n                    userInputDelayFlag: false,\n                    delayTime: 0,\n                    sortFlag: false,\n                    localColorTable: [],\n                    reserved: 0,\n                    GCreserved: 0,\n                });\n                frameIndex++;\n                transparencyIndex = -1;\n                incrementFrameIndex = false;\n            }\n        } while (!(await parseBlock(byteStream, gif, avgAlpha, getframeIndex, getTransparencyIndex, progressCallback)));\n        gif.frames.length--;\n        for (const frame of gif.frames) {\n            if (frame.userInputDelayFlag && frame.delayTime === 0) {\n                gif.totalTime = Infinity;\n                break;\n            }\n            gif.totalTime += frame.delayTime;\n        }\n        return gif;\n    }\n    catch (error) {\n        if (error instanceof EvalError) {\n            throw new Error(`error while parsing frame ${frameIndex} \"${error.message}\"`);\n        }\n        throw error;\n    }\n}\nexport function drawGif(data) {\n    const { context, radius, particle, delta } = data, image = particle.image;\n    if (!image?.gifData || !image.gif) {\n        return;\n    }\n    const offscreenCanvas = new OffscreenCanvas(image.gifData.width, image.gifData.height), offscreenContext = offscreenCanvas.getContext(\"2d\");\n    if (!offscreenContext) {\n        throw new Error(\"could not create offscreen canvas context\");\n    }\n    offscreenContext.imageSmoothingQuality = \"low\";\n    offscreenContext.imageSmoothingEnabled = false;\n    offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n    if (particle.gifLoopCount === undefined) {\n        particle.gifLoopCount = image.gifLoopCount ?? defaultLoopCount;\n    }\n    let frameIndex = particle.gifFrame ?? defaultFrame;\n    const pos = { x: -image.gifData.width * half, y: -image.gifData.height * half }, frame = image.gifData.frames[frameIndex];\n    if (particle.gifTime === undefined) {\n        particle.gifTime = initialTime;\n    }\n    if (!frame.bitmap) {\n        return;\n    }\n    context.scale(radius / image.gifData.width, radius / image.gifData.height);\n    switch (frame.disposalMethod) {\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 0:\n            offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n            context.drawImage(offscreenCanvas, pos.x, pos.y);\n            offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n            break;\n        case 1:\n            offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n            context.drawImage(offscreenCanvas, pos.x, pos.y);\n            break;\n        case 2:\n            offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n            context.drawImage(offscreenCanvas, pos.x, pos.y);\n            offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n            if (!image.gifData.globalColorTable.length) {\n                offscreenContext.putImageData(image.gifData.frames[firstIndex].image, pos.x + frame.left, pos.y + frame.top);\n            }\n            else {\n                offscreenContext.putImageData(image.gifData.backgroundImage, pos.x, pos.y);\n            }\n            break;\n        case 3:\n            {\n                const previousImageData = offscreenContext.getImageData(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n                offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n                context.drawImage(offscreenCanvas, pos.x, pos.y);\n                offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n                offscreenContext.putImageData(previousImageData, origin.x, origin.y);\n            }\n            break;\n    }\n    particle.gifTime += delta.value;\n    if (particle.gifTime > frame.delayTime) {\n        particle.gifTime -= frame.delayTime;\n        if (++frameIndex >= image.gifData.frames.length) {\n            if (--particle.gifLoopCount <= defaultLoopCount) {\n                return;\n            }\n            frameIndex = firstIndex;\n            offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n        }\n        particle.gifFrame = frameIndex;\n    }\n    context.scale(image.gifData.width / radius, image.gifData.height / radius);\n}\nexport async function loadGifImage(image) {\n    if (image.type !== \"gif\") {\n        const { loadImage } = await import(\"../Utils.js\");\n        await loadImage(image);\n        return;\n    }\n    image.loading = true;\n    try {\n        image.gifData = await decodeGIF(image.source);\n        image.gifLoopCount = getGIFLoopAmount(image.gifData) ?? defaultLoopCount;\n        if (!image.gifLoopCount) {\n            image.gifLoopCount = Infinity;\n        }\n    }\n    catch {\n        image.error = true;\n    }\n    image.loading = false;\n}\n","import { errorPrefix } from \"@tsparticles/engine\";\nimport { replaceImageColor } from \"./Utils.js\";\nimport { drawGif } from \"./GifUtils/Utils.js\";\nconst double = 2, defaultAlpha = 1, sides = 12, defaultRatio = 1;\nexport class ImageDrawer {\n    constructor(engine) {\n        this.loadImageShape = async (imageShape) => {\n            if (!this._engine.loadImage) {\n                throw new Error(`${errorPrefix} image shape not initialized`);\n            }\n            await this._engine.loadImage({\n                gif: imageShape.gif,\n                name: imageShape.name,\n                replaceColor: imageShape.replaceColor ?? false,\n                src: imageShape.src,\n            });\n        };\n        this._engine = engine;\n    }\n    addImage(image) {\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        this._engine.images.push(image);\n    }\n    draw(data) {\n        const { context, radius, particle, opacity } = data, image = particle.image, element = image?.element;\n        if (!image) {\n            return;\n        }\n        context.globalAlpha = opacity;\n        if (image.gif && image.gifData) {\n            drawGif(data);\n        }\n        else if (element) {\n            const ratio = image.ratio, pos = {\n                x: -radius,\n                y: -radius,\n            }, diameter = radius * double;\n            context.drawImage(element, pos.x, pos.y, diameter, diameter / ratio);\n        }\n        context.globalAlpha = defaultAlpha;\n    }\n    getSidesCount() {\n        return sides;\n    }\n    async init(container) {\n        const options = container.actualOptions;\n        if (!options.preload || !this._engine.loadImage) {\n            return;\n        }\n        for (const imageData of options.preload) {\n            await this._engine.loadImage(imageData);\n        }\n    }\n    loadShape(particle) {\n        if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n            return;\n        }\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        const imageData = particle.shapeData;\n        if (!imageData) {\n            return;\n        }\n        const image = this._engine.images.find((t) => t.name === imageData.name || t.source === imageData.src);\n        if (!image) {\n            void this.loadImageShape(imageData).then(() => {\n                this.loadShape(particle);\n            });\n        }\n    }\n    particleInit(container, particle) {\n        if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n            return;\n        }\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        const images = this._engine.images, imageData = particle.shapeData;\n        if (!imageData) {\n            return;\n        }\n        const color = particle.getFillColor(), image = images.find((t) => t.name === imageData.name || t.source === imageData.src);\n        if (!image) {\n            return;\n        }\n        const replaceColor = imageData.replaceColor ?? image.replaceColor;\n        if (image.loading) {\n            setTimeout(() => {\n                this.particleInit(container, particle);\n            });\n            return;\n        }\n        void (async () => {\n            let imageRes;\n            if (image.svgData && color) {\n                imageRes = await replaceImageColor(image, imageData, color, particle);\n            }\n            else {\n                imageRes = {\n                    color,\n                    data: image,\n                    element: image.element,\n                    gif: image.gif,\n                    gifData: image.gifData,\n                    gifLoopCount: image.gifLoopCount,\n                    loaded: true,\n                    ratio: imageData.width && imageData.height\n                        ? imageData.width / imageData.height\n                        : image.ratio ?? defaultRatio,\n                    replaceColor: replaceColor,\n                    source: imageData.src,\n                };\n            }\n            if (!imageRes.ratio) {\n                imageRes.ratio = 1;\n            }\n            const fill = imageData.fill ?? particle.shapeFill, close = imageData.close ?? particle.shapeClose, imageShape = {\n                image: imageRes,\n                fill,\n                close,\n            };\n            particle.image = imageShape.image;\n            particle.shapeFill = imageShape.fill;\n            particle.shapeClose = imageShape.close;\n        })();\n    }\n}\n"],"names":["InterlaceOffsets","InterlaceSteps","ByteStream","bytes","this","pos","data","Uint8ClampedArray","count","slice","length","reduce","acc","curr","String","fromCharCode","blockString","size","len","offset","blockData","Uint8Array","i","origin","parseColorTable","byteStream","colors","push","r","g","b","parseExtensionBlock","gif","getFrameIndex","getTransparencyIndex","nextByte","frame","frames","packedByte","GCreserved","disposalMethod","userInputDelayFlag","transparencyFlag","delayTime","nextTwoBytes","transparencyIndex","applicationExtension","identifier","getString","authenticationCode","readSubBlocksBin","applicationExtensions","comments","readSubBlocks","globalColorTable","EvalError","plainTextData","left","top","width","height","charSize","foregroundColor","backgroundColor","text","skipSubBlocks","parseImageBlock","avgAlpha","progressCallback","a","localColorTableFlag","interlacedFlag","sortFlag","reserved","localColorCount","localColorTable","getColor","index","image","ImageData","colorSpace","error","DOMException","name","minCodeSize","imageData","clearCode","readBits","bytePos","bitPos","code","dic","pass","pixelPos","lineIndex","exit","last","concat","item","set","x","y","createImageBitmap","bitmap","parseBlock","getGIFLoopAmount","extension","NaN","decodeGIF","gifURL","fetch","res","ok","status","arrayBuffer","buffer","totalTime","colorRes","pixelAspectRatio","backgroundImage","Error","globalColorTableFlag","globalColorCount","backgroundColorIndex","copyWithin","frameIndex","incrementFrameIndex","getframeIndex","increment","newValue","Infinity","message","drawGif","context","radius","particle","delta","gifData","offscreenCanvas","OffscreenCanvas","offscreenContext","getContext","imageSmoothingQuality","imageSmoothingEnabled","clearRect","undefined","gifLoopCount","gifFrame","gifTime","scale","drawImage","putImageData","previousImageData","getImageData","value","loadGifImage","type","loadImage","loading","source","ImageDrawer","engine","loadImageShape","imageShape","_engine","errorPrefix","replaceColor","src","images","opacity","element","globalAlpha","ratio","diameter","container","options","actualOptions","preload","shape","shapeData","find","t","then","loadShape","color","getFillColor","setTimeout","particleInit","svgData","replaceImageColor","imageRes","loaded","fill","shapeFill","close","shapeClose"],"sourceRoot":""}