{"version":3,"file":"static/js/8613.14ce2a1d.chunk.js","mappings":"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","sources":["../node_modules/@tsparticles/interaction-particles-collisions/browser/Absorb.js","../node_modules/@tsparticles/interaction-particles-collisions/browser/Bounce.js","../node_modules/@tsparticles/interaction-particles-collisions/browser/ResolveCollision.js","../node_modules/@tsparticles/interaction-particles-collisions/browser/Destroy.js","../node_modules/@tsparticles/interaction-particles-collisions/browser/Collider.js"],"sourcesContent":["import { clamp } from \"@tsparticles/engine\";\nconst half = 0.5, absorbFactor = 10, minAbsorbFactor = 0;\nfunction updateAbsorb(p1, r1, p2, r2, delta, pixelRatio) {\n    const factor = clamp((p1.options.collisions.absorb.speed * delta.factor) / absorbFactor, minAbsorbFactor, r2);\n    p1.size.value += factor * half;\n    p2.size.value -= factor;\n    if (r2 <= pixelRatio) {\n        p2.size.value = 0;\n        p2.destroy();\n    }\n}\nexport function absorb(p1, p2, delta, pixelRatio) {\n    const r1 = p1.getRadius(), r2 = p2.getRadius();\n    if (r1 === undefined && r2 !== undefined) {\n        p1.destroy();\n    }\n    else if (r1 !== undefined && r2 === undefined) {\n        p2.destroy();\n    }\n    else if (r1 !== undefined && r2 !== undefined) {\n        if (r1 >= r2) {\n            updateAbsorb(p1, r1, p2, r2, delta, pixelRatio);\n        }\n        else {\n            updateAbsorb(p2, r2, p1, r1, delta, pixelRatio);\n        }\n    }\n}\n","import { circleBounce, circleBounceDataFromParticle, getRangeValue } from \"@tsparticles/engine\";\nconst fixBounceSpeed = (p) => {\n    if (p.collisionMaxSpeed === undefined) {\n        p.collisionMaxSpeed = getRangeValue(p.options.collisions.maxSpeed);\n    }\n    if (p.velocity.length > p.collisionMaxSpeed) {\n        p.velocity.length = p.collisionMaxSpeed;\n    }\n};\nexport function bounce(p1, p2) {\n    circleBounce(circleBounceDataFromParticle(p1), circleBounceDataFromParticle(p2));\n    fixBounceSpeed(p1);\n    fixBounceSpeed(p2);\n}\n","import { absorb } from \"./Absorb.js\";\nimport { bounce } from \"./Bounce.js\";\nimport { destroy } from \"./Destroy.js\";\nexport function resolveCollision(p1, p2, delta, pixelRatio) {\n    switch (p1.options.collisions.mode) {\n        case \"absorb\": {\n            absorb(p1, p2, delta, pixelRatio);\n            break;\n        }\n        case \"bounce\": {\n            bounce(p1, p2);\n            break;\n        }\n        case \"destroy\": {\n            destroy(p1, p2);\n            break;\n        }\n    }\n}\n","import { bounce } from \"./Bounce.js\";\nexport function destroy(p1, p2) {\n    if (!p1.unbreakable && !p2.unbreakable) {\n        bounce(p1, p2);\n    }\n    if (p1.getRadius() === undefined && p2.getRadius() !== undefined) {\n        p1.destroy();\n    }\n    else if (p1.getRadius() !== undefined && p2.getRadius() === undefined) {\n        p2.destroy();\n    }\n    else if (p1.getRadius() !== undefined && p2.getRadius() !== undefined) {\n        const deleteP = p1.getRadius() >= p2.getRadius() ? p2 : p1;\n        deleteP.destroy();\n    }\n}\n","import { ParticlesInteractorBase, getDistance } from \"@tsparticles/engine\";\nimport { resolveCollision } from \"./ResolveCollision.js\";\nconst double = 2;\nexport class Collider extends ParticlesInteractorBase {\n    constructor(container) {\n        super(container);\n    }\n    clear() {\n    }\n    init() {\n    }\n    interact(p1, delta) {\n        if (p1.destroyed || p1.spawning) {\n            return;\n        }\n        const container = this.container, pos1 = p1.getPosition(), radius1 = p1.getRadius(), query = container.particles.quadTree.queryCircle(pos1, radius1 * double);\n        for (const p2 of query) {\n            if (p1 === p2 ||\n                !p2.options.collisions.enable ||\n                p1.options.collisions.mode !== p2.options.collisions.mode ||\n                p2.destroyed ||\n                p2.spawning) {\n                continue;\n            }\n            const pos2 = p2.getPosition(), radius2 = p2.getRadius();\n            if (Math.abs(Math.round(pos1.z) - Math.round(pos2.z)) > radius1 + radius2) {\n                continue;\n            }\n            const dist = getDistance(pos1, pos2), distP = radius1 + radius2;\n            if (dist > distP) {\n                continue;\n            }\n            resolveCollision(p1, p2, delta, container.retina.pixelRatio);\n        }\n    }\n    isEnabled(particle) {\n        return particle.options.collisions.enable;\n    }\n    reset() {\n    }\n}\n"],"names":["updateAbsorb","p1","r1","p2","r2","delta","pixelRatio","factor","clamp","options","collisions","absorb","speed","size","value","destroy","fixBounceSpeed","p","undefined","collisionMaxSpeed","getRangeValue","maxSpeed","velocity","length","bounce","circleBounce","circleBounceDataFromParticle","resolveCollision","mode","getRadius","unbreakable","Collider","container","destroyed","spawning","this","pos1","getPosition","radius1","query","particles","quadTree","queryCircle","enable","pos2","radius2","Math","abs","round","z","getDistance","retina","particle","ParticlesInteractorBase"],"sourceRoot":""}